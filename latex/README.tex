% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{mathtools}
\usepackage{braket}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={The Meßthaler-Wulff Project},
  pdfauthor={Julia Meßthaler},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{The Meßthaler-Wulff Project}
\author{Julia Meßthaler}
\date{}

\begin{document}
\maketitle

Blazingly fast code for finding all crystals (subsets of a graph) that
can be constructed using only transformations that locally minimize
surface energy.

\hypertarget{the-problem}{%
\subsection{The Problem}\label{the-problem}}

Let \(G\) be some graph and \(C \subset G\) a crystal. Furthermore let
\(\eta: G \rightarrow \wp(G)\) denote the neighbors of a given node.
Then we can define the surface energy of the crystal \(C\) as \[
\xi_C \coloneq \sum_{n \in C} l_n^1
\] where \(l_n^1\) denotes the forwards loneliness of the node \(n\) and
is itself defined as \[
l_n^1 \coloneq \# \{ n_0 \in \eta(n) \mid n_0 \not\in C \}
\]

The idea now is to find optimal \(\xi_C\) by doing locally minimizing
transformations. We call a node \(n\) optimal in forwards mode if for
the specific \(C\) there is no node \(n_0\) such that
\(l_{n_0}^1 < l_n^1\). The same definition can be applied to backwards
mode, for this however we use
\(l_n^0 \coloneq \#\{ n_0 \in \eta(n) \mid n_0 \in C \}\).

A locally optimal addition is now simply a node with optimal \(l_n^1\)
and a locally optimal removal is a node with optimal \(l_n^0\).

Our goal in this project is to explore what crystals we can construct by
only using such locally optimal transformations.

\hypertarget{the-additive-simulation}{%
\subsection{The Additive Simulation}\label{the-additive-simulation}}

This class encapsulates a current state representing a crystal and
methods to find out what locally optimal transformations can be applied
or to apply said transformations. It is optimized to be able to support
\(O(1)\) operations. A simplified definition of an additive simulation
instance is \(S_A = (\xi_C, B_0, B_1)\) where \(\xi_C\) is the energy of
the current crystal and \(B_i\) are the boundaries, defined as follows:
\[
B_i = \{ n \in C \mid l_n^{1-i} > 0 \}
\]

The boundaries are represented by \texttt{PriorityStack} instances and
support the following operations:

\begin{itemize}
\tightlist
\item
  Getting the loneliness for a node
\item
  Setting the loneliness for a node
\item
  Unsetting the loneliness for a node, effectively removing it from the
  boundary
\item
  Getting the nodes that have minimal loneliness
\end{itemize}

In its essence \texttt{PriorityStack} is an implementation of a priority
queue optimized for this specific use-case.

\(S_A\) now basically only has to support one operation: Moving a node
from one boundary to the other.

Let \(n\) be the affected node and \(m\) the mode\footnote{This is 0 for
  backwards and 1 for forwards}. If \(m=1\) the energy becomes
\[\xi_C' = \xi_C + l_n^1 - l_n^0\]
\[=\xi_C + l_n^1 - (\#\eta(n)-l_n^1)\] \[=\xi_C + 2l_n^1 - \#\eta(n)\]
Since backwards and forwards are inverse for \(m=0\) the energy must be
\[\xi_C' = \xi_C - l_n^1 + l_n^0\]
\[=\xi_C + l_n^0 - (\#\eta(n)-l_n^0)\] \[=\xi_C + 2l_n^0 - \#\eta(n)\]

\end{document}
